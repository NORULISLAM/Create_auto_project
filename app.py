from __future__ import annotations

import os
import shutil
import time
import zipfile
from pathlib import Path

import gradio as gr
from fastapi import FastAPI, Response
from fastapi.staticfiles import StaticFiles
from gradio.themes.soft import Soft

# --- your agent + tools ---
from agent.graph import agent
from agent.tools import PROJECT_ROOT, init_project_root

# -----------------------
# FastAPI app + static
# -----------------------
app = FastAPI(title="Coder-Uncle Demo")


@app.get("/manifest.json")
def manifest():
    return {
        "name": "Coder Uncle ‚Äì Demo",
        "short_name": "CoderUncle",
        "start_url": "/",
        "display": "standalone",
        "background_color": "#ffffff",
        "theme_color": "#000000",
        "icons": [],
    }


@app.get("/favicon.ico")
def favicon():
    return Response(b"", media_type="image/x-icon")


init_project_root()
# Serve generated files under /preview
app.mount("/preview", StaticFiles(directory=str(PROJECT_ROOT), html=True), name="preview")


# -----------------------
# Helpers
# -----------------------
def _reset_output_dir() -> None:
    if PROJECT_ROOT.exists():
        shutil.rmtree(PROJECT_ROOT, ignore_errors=True)
    PROJECT_ROOT.mkdir(parents=True, exist_ok=True)


def _zip_project(dir_path: Path) -> str:
    """
    Create a ZIP file with a stable name next to the generated site directory.

    Example:
      PROJECT_ROOT = /.../generated_site
      ZIP path     = /.../generated_site.zip
    """
    zip_path = (dir_path.parent / f"{dir_path.name}.zip").resolve()
    if zip_path.exists():
        try:
            zip_path.unlink()
        except Exception:
            pass

    with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zf:
        for root, _, files in os.walk(dir_path):
            for fn in files:
                full = Path(root) / fn
                zf.write(full, arcname=str(full.relative_to(dir_path)))
    return str(zip_path)


def _dir_has_files(dir_path: Path) -> bool:
    for _, _, files in os.walk(dir_path):
        if files:
            return True
    return False


def _ensure_placeholder_index(dir_path: Path) -> None:
    """Create a fallback index.html that lists whatever files were generated, if index.html is missing."""
    index_path = dir_path / "index.html"
    if index_path.exists():
        return
    # Build a simple directory listing with links
    items = []
    for root, _, files in os.walk(dir_path):
        for fn in sorted(files):
            full = Path(root) / fn
            rel = full.relative_to(dir_path).as_posix()
            if rel == "index.html":
                continue
            items.append(f'<li><a href="{rel}" target="_blank">{rel}</a></li>')
    listing = "\n".join(items) or "<li>(No files found)</li>"
    html = f"""<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Generated Output (Fallback)</title>
  <style>
    body {{ font-family: system-ui, Arial, sans-serif; margin: 24px; }}
    .note {{ background: #fff8e1; border: 1px solid #ffe082; padding: 12px; border-radius: 8px; margin-bottom: 16px; }}
  </style>
</head>
<body>
  <h1>Generated Output (Fallback)</h1>
  <div class="note">
    No <code>index.html</code> was generated by the pipeline, so this fallback page lists all files created.
  </div>
  <ul>
    {listing}
  </ul>
</body>
</html>"""
    index_path.write_text(html, encoding="utf-8")


def _invoke_agent_with_retries(user_prompt: str, recursion_limit: int) -> None:
    """Call the LangGraph agent with exponential backoff on 429s (rate limits)."""
    recursion_limit = int(max(5, min(recursion_limit, 40)))
    max_retries = 3
    base_delay = 8  # seconds

    # Optional: choose a lighter model in your graph if it reads env
    # os.environ.setdefault("GROQ_MODEL", "llama-3.1-8b-instant")

    for attempt in range(1, max_retries + 1):
        try:
            agent.invoke({"user_prompt": user_prompt}, {"recursion_limit": recursion_limit})
            return
        except Exception as e:
            msg = str(e).lower()
            retryable = ("429" in msg) or ("rate limit" in msg) or ("tpm" in msg)
            if attempt < max_retries and retryable:
                time.sleep(base_delay * attempt)  # simple backoff
                recursion_limit = max(5, recursion_limit - 5)  # shrink work each retry
                continue
            raise  # not retryable or exhausted


def _iframe(url: str, h: int = 700) -> str:
    return f'<iframe src="{url}" style="width:100%;height:{h}px;border:1px solid #ddd;border-radius:8px;"></iframe>'


def run_generation(prompt: str, recursion_limit: int = 20):
    logs = []
    try:
        logs.append("üöß Preparing output folder‚Ä¶")
        _reset_output_dir()

        logs.append("ü§ñ Running LangGraph pipeline (planner ‚Üí architect ‚Üí coder)‚Ä¶")
        _invoke_agent_with_retries(prompt, recursion_limit)

        # Success path
        if not _dir_has_files(PROJECT_ROOT):
            logs.append("‚ö†Ô∏è Pipeline finished but wrote no files.")
            return "\n".join(logs), None, "<div style='color:#b45309'>No files were generated.</div>"

        # Ensure index.html exists for preview
        _ensure_placeholder_index(PROJECT_ROOT)

        logs.append("üß© Build complete. Creating ZIP‚Ä¶")
        zip_path = _zip_project(PROJECT_ROOT)

        preview_url = "/preview/index.html"
        logs.append(f"üåê Preview ready at {preview_url}")
        logs.append("‚úÖ Done.")
        return "\n".join(logs), zip_path, _iframe(preview_url)

    except Exception as e:
        # Failure path (e.g., 429 / tool errors)
        emsg = str(e)
        friendly = [f"‚ùå Error: {emsg}"]
        if any(k in emsg.lower() for k in ["429", "rate limit", "tpm"]):
            friendly.append(
                "üí° Tip: You hit a free-tier token-per-minute limit. "
                "Try again shortly or lower the Recursion Limit. "
                "Using a smaller model in your graph can also help."
            )

        # If the agent partially wrote files, still package and preview them
        if _dir_has_files(PROJECT_ROOT):
            friendly.append("‚ö†Ô∏è Partial output detected. Creating fallback index and ZIP from what exists‚Ä¶")
            _ensure_placeholder_index(PROJECT_ROOT)
            zip_path = _zip_project(PROJECT_ROOT)
            preview_url = "/preview/index.html"
            friendly.append(f"üåê Preview (partial) at {preview_url}")
            friendly.append("‚úÖ You can still inspect and download the partial result.")
            return "\n".join(friendly), zip_path, _iframe(preview_url)

        # Nothing to show
        friendly.append("üõë No files were generated.")
        return "\n".join(friendly), None, "<div style='color:red'>Generation failed.</div>"


def smoke_test_zip():
    """
    Quick self-test that does NOT call the LLM:
    - creates /preview/hello.txt
    - builds a fallback index.html
    - zips the folder
    """
    _reset_output_dir()
    (PROJECT_ROOT / "hello.txt").write_text("hello world", encoding="utf-8")
    _ensure_placeholder_index(PROJECT_ROOT)
    zip_path = _zip_project(PROJECT_ROOT)
    return "‚úÖ Smoke test: created hello.txt and zipped it.", zip_path, _iframe("/preview/index.html")


# -----------------------
# Gradio UI
with gr.Blocks(theme=Soft(), analytics_enabled=False) as demo:
    gr.Markdown("# Coder-Uncle ‚Äì Live Demo\nType a prompt, watch logs, preview the site, then download the ZIP.")

    with gr.Row():
        prompt = gr.Textbox(
            label="Prompt",
            placeholder="e.g., Build a colorful modern TODO app with HTML, CSS, and JS",
            lines=3,
            value="Build a colorful modern TODO app with HTML, CSS, and JS",
        )

    with gr.Row():
        recursion = gr.Slider(5, 40, value=20, step=5, label="Recursion Limit (lower = fewer tokens)")

    with gr.Row():
        run_btn = gr.Button("Generate", variant="primary")
        smoke_btn = gr.Button("Make Test ZIP (no LLM)")

    logs = gr.Textbox(label="Logs", lines=14)
    # IMPORTANT: no file_name= here; Gradio uses the filename of the provided path
    zip_btn = gr.DownloadButton(label="Download ZIP", value=None)
    preview = gr.HTML()

    def on_click(p, r):
        out_logs, out_zip, out_iframe = run_generation(p, r)
        return out_logs, out_zip, out_iframe

    run_btn.click(on_click, [prompt, recursion], [logs, zip_btn, preview])
    smoke_btn.click(lambda: smoke_test_zip(), [], [logs, zip_btn, preview])


# Mount Gradio on FastAPI at root
app = gr.mount_gradio_app(app, demo, path="/")


if __name__ == "__main__":
    import uvicorn
    # visit http://127.0.0.1:7860
    uvicorn.run(app, host="127.0.0.1", port=7860)
